#include "MMask.h"

#include <cmath>

ClassImp(MMask)
ClassImp(MMLS)

//https://users.ece.cmu.edu/~koopman/lfsr/index.html

namespace LSFR {
std::vector<int> LSFR_2{0x3};
std::vector<int> LSFR_3{0x6};
std::vector<int> LSFR_4{0x9, 0xC};
std::vector<int> LSFR_5{0x12, 0x14, 0x17, 0x1B, 0x1D, 0x1E};
std::vector<int> LSFR_6{0x21, 0x2D, 0x30, 0x33, 0x36, 0x39};
std::vector<int> LSFR_7{0x41, 0x44, 0x47, 0x48, 0x4E, 0x53, 0x55, 0x5C, 0x5F, 0x60, 0x65, 0x69, 0x6A, 0x72, 0x77, 0x78, 0x7B, 0x7E};
std::vector<int> LSFR_8{0x8E, 0x95, 0x96, 0xA6, 0xAF, 0xB1, 0xB2, 0xB4, 0xB8, 0xC3, 0xC6, 0xD4, 0xE1, 0xE7, 0xF3, 0xFA};
std::vector<int> LSFR_9{0x108, 0x10D, 0x110, 0x116, 0x119, 0x12C, 0x12F, 0x134, 0x137, 0x13B, 0x13E, 0x143, 0x14A, 0x151, 0x152, 0x157, 0x15B, 0x15E, 0x167, 0x168, 0x16D, 0x17A, 0x17C, 0x189, 0x18A, 0x18F, 0x191, 0x198, 0x19D, 0x1A7, 0x1AD, 0x1B0, 0x1B5, 0x1B6, 0x1B9, 0x1BF, 0x1C2, 0x1C7, 0x1DA, 0x1DC, 0x1E3, 0x1E5, 0x1E6, 0x1EA, 0x1EC, 0x1F1, 0x1F4, 0x1FD};
std::vector<int> LSFR_10{0x204, 0x20D, 0x213, 0x216, 0x232, 0x237, 0x240, 0x245, 0x262, 0x26B, 0x273, 0x279, 0x27F, 0x286, 0x28C, 0x291, 0x298, 0x29E, 0x2A1, 0x2AB, 0x2B5, 0x2C2, 0x2C7, 0x2CB, 0x2D0, 0x2E3, 0x2F2, 0x2FB, 0x2FD, 0x309, 0x30A, 0x312, 0x31B, 0x321, 0x327, 0x32D, 0x33C, 0x33F, 0x344, 0x35A, 0x360, 0x369, 0x36F, 0x37E, 0x38B, 0x38E, 0x390, 0x39C, 0x3A3, 0x3A6, 0x3AA, 0x3AC, 0x3B1, 0x3BE, 0x3C6, 0x3C9, 0x3D8, 0x3ED, 0x3F9, 0x3FC};
std::vector<int> LSFR_11{0x402, 0x40B, 0x415, 0x416, 0x423, 0x431, 0x432, 0x438, 0x43D, 0x446, 0x44A, 0x44F, 0x454, 0x458, 0x467, 0x468, 0x470, 0x473, 0x475, 0x47A, 0x486, 0x489, 0x492, 0x494, 0x49D, 0x49E, 0x4A2, 0x4A4, 0x4A8, 0x4AD, 0x4B9, 0x4BA, 0x4BF, 0x4C1, 0x4C7, 0x4D5, 0x4D6, 0x4DC, 0x4E3, 0x4EC, 0x4F2, 0x4FB, 0x500, 0x503, 0x509, 0x50A, 0x514, 0x524, 0x530, 0x536, 0x53C, 0x53F, 0x542, 0x548, 0x54E, 0x553, 0x555, 0x559, 0x55A, 0x56A, 0x56F, 0x574, 0x577, 0x578, 0x57D, 0x581, 0x584, 0x588, 0x599, 0x59F, 0x5A0, 0x5A5, 0x5AC, 0x5AF, 0x5B2, 0x5B7, 0x5BE, 0x5C3, 0x5C5, 0x5C9, 0x5CA, 0x5D7, 0x5DB, 0x5DE, 0x5E4, 0x5ED, 0x5EE, 0x5F3, 0x5F6, 0x605, 0x606, 0x60C, 0x60F, 0x62B, 0x630, 0x635, 0x639, 0x642, 0x644, 0x64B};
std::vector<int> LSFR_12{0x829, 0x834, 0x83D, 0x83E, 0x84C, 0x868, 0x875, 0x883, 0x88F, 0x891, 0x89D, 0x8A7, 0x8AB, 0x8B0, 0x8B5, 0x8C2, 0x8D9, 0x8EC, 0x8EF, 0x906, 0x91B, 0x91E, 0x933, 0x939, 0x93F, 0x95C, 0x960, 0x965, 0x987, 0x98E, 0x990, 0x99C, 0x99F, 0x9A6, 0x9B8, 0x9CC, 0x9D1, 0x9D4, 0xA03, 0xA18, 0xA1B, 0xA27, 0xA2E, 0xA33, 0xA3A, 0xA53, 0xA56, 0xA69, 0xA87, 0xA8E, 0xAA6, 0xAC9, 0xAE2, 0xAEB, 0xAEE, 0xAF5, 0xB04, 0xB23, 0xB2A, 0xB2C, 0xB52, 0xB5E, 0xB8A, 0xB8C, 0xBA1, 0xBA2, 0xBBA, 0xBC4, 0xBD6, 0xBD9, 0xBDF, 0xBE0, 0xC2B, 0xC2E, 0xC48, 0xC4B, 0xC5C, 0xC77, 0xC8D, 0xC9A, 0xCA0, 0xCB2, 0xCBD, 0xCC5, 0xCD8, 0xCDE, 0xCE4, 0xCE7, 0xCF3, 0xD0D, 0xD15, 0xD19, 0xD34, 0xD45, 0xD68, 0xD70, 0xD7A, 0xD85, 0xD89, 0xD8F};
std::vector<int> LSFR_13{0x100D, 0x1013, 0x101A, 0x1029, 0x1032, 0x1037, 0x1045, 0x1046, 0x104F, 0x1052, 0x1057, 0x105D, 0x105E, 0x1061, 0x1064, 0x1070, 0x1079, 0x1086, 0x108A, 0x1094, 0x1097, 0x109D, 0x10A1, 0x10B3, 0x10B5, 0x10BC, 0x10C4, 0x10CB, 0x10CE, 0x10DF, 0x10E0, 0x10E3, 0x10E6, 0x10EF, 0x10F1, 0x10F8, 0x10FD, 0x110C, 0x1112, 0x111B, 0x111E, 0x1121, 0x112D, 0x112E, 0x113C, 0x113F, 0x1144, 0x114B, 0x114D, 0x1159, 0x115F, 0x1166, 0x1177, 0x117B, 0x117D, 0x1182, 0x1193, 0x1195, 0x11A3, 0x11AA, 0x11AC, 0x11B7, 0x11B8, 0x11BE, 0x11C3, 0x11C6, 0x11CA, 0x11D1, 0x11D4, 0x11D8, 0x11DB, 0x11DD, 0x11F0, 0x11F6, 0x11FC, 0x1205, 0x1209, 0x120F, 0x1212, 0x1214, 0x121E, 0x1228, 0x122B, 0x1230, 0x1236, 0x123F, 0x1241, 0x124D, 0x124E, 0x125A, 0x125F, 0x1260, 0x1263, 0x1265, 0x1271, 0x1284, 0x128B, 0x128E, 0x1290, 0x1296};
std::vector<int> LSFR_14{0x2015, 0x201C, 0x2029, 0x202F, 0x203D, 0x2054, 0x2057, 0x205D, 0x205E, 0x2067, 0x2075, 0x2079, 0x2086, 0x2089, 0x209D, 0x20A1, 0x20CD, 0x20CE, 0x20D3, 0x20D6, 0x20DA, 0x20EA, 0x20EC, 0x20F8, 0x2106, 0x212B, 0x2130, 0x213F, 0x2142, 0x214E, 0x2163, 0x2165, 0x2166, 0x2171, 0x2174, 0x2177, 0x2184, 0x2190, 0x219F, 0x21BE, 0x21C3, 0x21CA, 0x21D7, 0x21E4, 0x21F5, 0x21F6, 0x2205, 0x2221, 0x2239, 0x2269, 0x226A, 0x226F, 0x2271, 0x227D, 0x2295, 0x229C, 0x22AC, 0x22B7, 0x22CC, 0x22CF, 0x22D2, 0x22DB, 0x22E2, 0x22EB, 0x22F3, 0x22F9, 0x22FF, 0x2307, 0x230E, 0x2313, 0x231A, 0x2323, 0x232C, 0x2331, 0x2338, 0x233D, 0x2352, 0x2362, 0x2367, 0x236D, 0x2398, 0x23A7, 0x23BF, 0x23D3, 0x23E0, 0x23F2, 0x23F4, 0x23F7, 0x2409, 0x240C, 0x241D, 0x2421, 0x242D, 0x2430, 0x2433, 0x243F, 0x2441, 0x2471, 0x248E, 0x2496};
std::vector<int> LSFR_15{0x4001, 0x4008, 0x400B, 0x4016, 0x401A, 0x402F, 0x403B, 0x4040, 0x4043, 0x4049, 0x4052, 0x4061, 0x4067, 0x406E, 0x4073, 0x407A, 0x4080, 0x408A, 0x4092, 0x40AB, 0x40AE, 0x40B0, 0x40B6, 0x40C2, 0x40D0, 0x40D3, 0x40DC, 0x40E5, 0x40E6, 0x40EF, 0x40FE, 0x4109, 0x411D, 0x4122, 0x413F, 0x4144, 0x4147, 0x414D, 0x4165, 0x416C, 0x418B, 0x418D, 0x4195, 0x4199, 0x41A3, 0x41A6, 0x41AF, 0x41B1, 0x41B4, 0x41B8, 0x41C5, 0x41CC, 0x41D7, 0x41DE, 0x41E2, 0x41E8, 0x420C, 0x4211, 0x4217, 0x4218, 0x421B, 0x4233, 0x4236, 0x423C, 0x4241, 0x424B, 0x4250, 0x425A, 0x426F, 0x427B, 0x427E, 0x428E, 0x4290, 0x4293, 0x4299, 0x42A3, 0x42A5, 0x42AF, 0x42B8, 0x42BD, 0x42C0, 0x42C6, 0x42D1, 0x42D8, 0x42E2, 0x42E4, 0x42ED, 0x42F6, 0x42F9, 0x4304, 0x4308, 0x430E, 0x4315, 0x432A, 0x432C, 0x4332, 0x433E, 0x4340, 0x4354, 0x4357};
}

//------------------------------------------------------------
void MMask::BuildHisto()
{
	m_histo.SetStats(false);
	m_histo.SetDirectory(0);

	auto nx = m_mtx.GetNcols();
	auto ny = m_mtx.GetNrows();
	for(auto i = 0; i < nx; i++)
		for(int j = 0; j < ny; j++)
		{
			m_histo.SetBinContent(i+1,j+1,m_mtx[ny-j-1][i]);
		}
}

//------------------------------------------------------------
void MMask::Draw()
{
	m_histo.Draw("colz");
}

//------------------------------------------------------------
bool MMask::Is_Transparet(double x, double y)
{
	return (m_histo.GetBinContent(m_histo.FindBin(x,y)) == 1.) ? true : false;
}

//------------------------------------------------------------

std::map<int, std::vector<int>*>* MMLS::m_LSFR = 0;
bool MMLS::m_isinit = false;

//------------------------------------------------------------
void MMLS::Init()
{
	if(!m_isinit)
	{
		m_LSFR = new std::map<int, std::vector<int>*>();
		m_LSFR->insert(std::pair<int, std::vector<int>*>(2,&LSFR::LSFR_2));
		m_LSFR->insert(std::pair<int, std::vector<int>*>(3,&LSFR::LSFR_3));
		m_LSFR->insert(std::pair<int, std::vector<int>*>(4,&LSFR::LSFR_4));
		m_LSFR->insert(std::pair<int, std::vector<int>*>(5,&LSFR::LSFR_5));
		m_LSFR->insert(std::pair<int, std::vector<int>*>(6,&LSFR::LSFR_6));
		m_LSFR->insert(std::pair<int, std::vector<int>*>(7,&LSFR::LSFR_7));
		m_LSFR->insert(std::pair<int, std::vector<int>*>(8,&LSFR::LSFR_8));
		m_LSFR->insert(std::pair<int, std::vector<int>*>(9,&LSFR::LSFR_9));
		m_LSFR->insert(std::pair<int, std::vector<int>*>(10,&LSFR::LSFR_10));
		m_LSFR->insert(std::pair<int, std::vector<int>*>(11,&LSFR::LSFR_11));
		m_LSFR->insert(std::pair<int, std::vector<int>*>(12,&LSFR::LSFR_12));
		m_LSFR->insert(std::pair<int, std::vector<int>*>(13,&LSFR::LSFR_13));
		m_LSFR->insert(std::pair<int, std::vector<int>*>(14,&LSFR::LSFR_14));
		m_LSFR->insert(std::pair<int, std::vector<int>*>(15,&LSFR::LSFR_15));
		m_isinit = true;
	}
}

//------------------------------------------------------------
void MMLS::Build()
{
	auto _lsfr = m_LSFR->at(m_nreg)->at(m_idLSFR);
	auto _length = std::pow(2,m_nreg) - 1;
	auto _value = 0;
	auto _index = 0;

	std::vector<int> _register(m_nreg,1);

	m_seq.resize(_length);

	for(auto i = _length - 1; i >= 0; i--)
	{
		m_seq.at(i) = (_register.back() == 0) ? -1 : 1;

		_value = 0;
		_index = -1;

		while(++_index < m_nreg)
			if((_lsfr >> _index) & 1)
				_value += _register.at(_index);

		std::rotate(_register.rbegin(), _register.rbegin() + 1, _register.rend());

		_register.front() = _value % 2;
	}

	std::rotate(m_seq.begin(), m_seq.begin() + 1, m_seq.end());
}

//------------------------------------------------------------
TH1I& MMLS::GetHisto()
{
	Build();
	auto h = new TH1I("","",m_seq.size(), 0, m_seq.size());
	h->SetStats(false);
	for(auto i = 0; i < h->GetNbinsX(); i++)
	{
		h->SetBinContent(i+1, m_seq[i]);
	}
	return *h;
}

//------------------------------------------------------------
MCode::MCode(std::vector<int> w_ver, std::vector<int> w_hor, int n_ver = 1, int n_hor = 1) : m_nrepV(n_ver), m_nrepH(n_hor), m_mtx(w_ver.size() * n_ver, w_hor.size() * n_hor)
{
	for(auto kv = 0; kv < n_ver; kv++)
		for(auto kh = 0; kh < n_hor; kh++)
			for(auto i = 0u; i < w_ver.size(); i++)
				for(auto j = 0u; j < w_hor.size(); j++)
					m_mtx[i + kv * w_ver.size()][j + kh * w_hor.size()] = (w_ver.at(i) * w_hor.at(j) == 1) ? 1 : 0;
}

//------------------------------------------------------------
MCode::MCode(TMatrixD mtx, int n_ver = 1, int n_hor = 1) : m_nrepV(n_ver), m_nrepH(n_hor), m_mtx(mtx.GetNrows() * n_ver, mtx.GetNcols() * n_hor)
{
	for(auto kv = 0; kv < n_ver; kv++)
		for(auto kh = 0; kh < n_hor; kh++)
			for(auto i = 0; i < mtx.GetNrows(); i++)
				for(auto j = 0; j < mtx.GetNcols(); j++)
					m_mtx[i + kv * mtx.GetNrows()][j + kh * mtx.GetNcols()] = (mtx[i][j] == 1) ? 1 : 0;
}

//------------------------------------------------------------
MCode::MCode(MCode& code)
{
	m_nrepV = code.m_nrepV;
	m_nrepH = code.m_nrepH;

	m_mtx = code.m_mtx;
}
